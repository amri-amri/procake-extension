package de.uni_trier.wi2.parsing;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;
import de.uni_trier.wi2.parsing.model.*;
import de.uni_trier.wi2.utils.MethodInvoker;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;


public abstract class JSONtoFunctionConverter {

    /**
     * <p>returns the Java Object of which the given Map is the JSON-representation of
     *
     * <p>This function is the heartpiece of the JSONtoFunctionConverter.
     * After a JSON-representation of a functional Interface (MethodInvokersFunc, SimilarityMeasureFunc or WeightFunc)
     * has been converted in to a LinkedHashMap by the xml parser, the respective nodes have to be evaluated
     * using this function.
     *
     * <p>In order to evaluate the nodes \<q\\\> or \<c\\\> (see JSON schema), DataObjects q and c
     * have to be passed to the function, as well.
     *
     * <p>In case a functional Interface requires only one argument, q, c can be set so null.
     *
     * @param node the DOM node generated by the xml parser
     * @return the Java Object of which the DOM node is the XML-representation
     * @throws ClassNotFoundException
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    protected static Component evaluate(Map node) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {

        switch ((String) node.get("element-type")) {

            // The "and" node represents the logical conjunction of the nodes in the list under "content"
            case "and":
                List<Map> conditions = (List<Map>) node.get("content");
                int amountOfConditions = conditions.size();
                LogicalOrConditionComponent[] logicalOrConditionComponents = new LogicalOrConditionComponent[amountOfConditions];
                for (int i = 0; i < amountOfConditions; i++) {
                    logicalOrConditionComponents[i] = (LogicalOrConditionComponent) evaluate(conditions.get(i));
                }
                return new AndComponent(logicalOrConditionComponents);

            // The "and" node represents the logical conjunction of the nodes in the list under "content"
            case "or":
                conditions = (List<Map>) node.get("content");
                amountOfConditions = conditions.size();
                logicalOrConditionComponents = new LogicalOrConditionComponent[amountOfConditions];
                for (int i = 0; i < amountOfConditions; i++) {
                    logicalOrConditionComponents[i] = (LogicalOrConditionComponent) evaluate(conditions.get(i));
                }
                return new OrComponent(logicalOrConditionComponents);

            // The "not" node represents the logical negation the node under "content"
            case "not":
                return new NotComponent((LogicalOrConditionComponent) evaluate((Map) node.get("content")));

            // The "equals" node represents Java's "Object.equals" method
            case "equals":
                ObjectOrValueComponent a = (ObjectOrValueComponent) evaluate((Map) node.get("a"));
                ObjectOrValueComponent b = (ObjectOrValueComponent) evaluate((Map) node.get("b"));
                return new EqualsComponent(a, b);

            // The "equals" node represents Java's "==" equality
            case "same-object-as":
                a = (ObjectOrValueComponent) evaluate((Map) node.get("a"));
                b = (ObjectOrValueComponent) evaluate((Map) node.get("b"));
                return new SameObjectAsComponent(a, b);

            // The "instance-of" node represents Java's "instanceof" operator
            case "instance-of":
                a = (ObjectComponent) evaluate((Map) node.get("a"));
                StringComponent clazz = (StringComponent) evaluate((Map) node.get("b"));
                return new InstanceOfComponent((ObjectComponent) a, clazz);

            // The "regex" node represents a regular expression test
            // It returns true if the string value under "b" matches the string value under "a"
            case "regex":
                StringOrMethodReturnValueComponent pattern = (StringOrMethodReturnValueComponent) evaluate((Map) node.get("pattern"));
                StringOrMethodReturnValueComponent matcher = (StringOrMethodReturnValueComponent) evaluate((Map) node.get("matcher"));
                return new RegexComponent(pattern, matcher);

            // The "q" node represents the first argument passed to the functional interface which is generated by the
            //  respective converter
            case "q":
                return new QComponent();

            // The "c" node represents the second argument passed to the functional interface which is generated by the
            //  respective converter (if the functional interface requires one)
            case "c":
                return new CComponent();

            // The "string" node represents a String object
            case "string":
                String str = (String) node.get("value");
                return new StringComponent(str);

            // The "double" node represents a Double object
            case "double":
                double dbl;
                Object val = node.get("value");
                if (val instanceof Double) {
                    dbl = (double) val;
                } else if (val instanceof Integer) {
                    dbl = (int) val;
                } else {
                    dbl = Double.parseDouble((String) node.get("value"));
                }
                return new DoubleComponent(dbl);

            // The "boolean" node represents a Boolean object
            case "boolean":
                boolean bool;
                val = node.get("value");
                if (val instanceof Double) {
                    bool = ((double) val) > 0;
                } else if (val instanceof Integer) {
                    bool = ((int) val) > 0;
                } else {
                    bool = Boolean.parseBoolean((String) node.get("value"));
                }
                return new BooleanComponent(bool);

            // The "character" node represents a Character object
            case "character":
                char chr = ((String) node.get("value")).charAt(0);
                return new CharacterComponent(chr);

            // The "integer" node represents a Integer object
            case "integer":
                Integer itg = Integer.parseInt((String) node.get("value"));

                return new IntegerComponent(itg);

            // The "method" node represents a method in Java.
            // A "method" node has an attribute "name" (=name of method) and arbitrarily many
            //  child nodes of node string, double or boolean.
            case "method":
                String name = (String) node.get("name");
                List<Map> arguments = (List<Map>) node.get("arguments");
                int size = 0;
                if (arguments!=null) size = arguments.size();

                ValueComponent[] argumentComponents = new ValueComponent[size];

                for (int i = 0; i < size; i++) {
                    Map argument = arguments.get(i);
                    ValueComponent argComp;
                    if (argument.get("element-type").equals("string"))
                        argComp = new StringComponent((String) argument.get("value"));
                    else if (argument.get("element-type").equals("double"))
                        argComp = new DoubleComponent((Double) argument.get("value"));
                    else if (argument.get("element-type").equals("boolean"))
                        argComp = new BooleanComponent((Boolean) argument.get("value"));
                    else if (argument.get("element-type").equals("character"))
                        argComp = new CharacterComponent((Character) argument.get("value"));
                    else if (argument.get("element-type").equals("integer"))
                        argComp = new IntegerComponent((Integer) argument.get("value"));
                    else
                        throw new RuntimeException("Unknown element-type \"" + argument.get("element-type") + "\"");
                    argumentComponents[i] = argComp;
                }
                return new MethodComponent(name, argumentComponents);

            // The "method-return-value" node represents the return value of a method (see above)
            case "method-return-value":
                return new MethodReturnValueComponent((ObjectComponent) evaluate((Map) node.get("object")), (MethodComponent) evaluate((Map) node.get("method")));

            // The "method-list" node represents a list of methods
            case "method-list":
                ArrayList<MethodInvoker> methodInvokers = new ArrayList<>();
                List<Map> methods = (List<Map>) node.get("content");
                MethodComponent[] methodComponents = new MethodComponent[methods.size()];
                for (int i = 0; i < methods.size(); i++) {
                    methodComponents[i] = (MethodComponent) evaluate(methods.get(i));
                }
                return new MethodListComponent(methodComponents);
            case "function":
                name = (String) node.get("name");
                String arg1 = (String) node.get("arg1");
                String arg2 = (String) node.get("arg2");
                String arg3 = (String) node.get("arg3");
                return new FunctionComponent(name, arg1, arg2, arg3);
            default:
                break;

            //TODO: Test JSONtoFunctionalInterfaceConverters!!!

        }
        return null;
    }

    /**
     * <p>Validates a JSON file (.json) gainst a JSON schema (.jschema) and returns the {@link ValidationMessage}s.</p>
     *
     * @param schema the JSON schema to be validated against
     * @param json   the JSON file to be validated
     * @return set of ValidationMessages
     * @throws JsonProcessingException if the String json does not contain a well-formed JSON document
     */
    protected static Set<ValidationMessage> validate(String schema, String json) throws JsonProcessingException {
        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V4);
        JsonSchema jsonSchema = factory.getSchema(schema);
        JsonNode jsonNode = new ObjectMapper().readTree(json);
        Set<ValidationMessage> errors = jsonSchema.validate(jsonNode);

        return errors;
    }
}
