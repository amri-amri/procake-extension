package de.uni_trier.wi2.parsing;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;
import de.uni_trier.wi2.procake.data.object.DataObject;
import de.uni_trier.wi2.utils.MethodInvoker;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static de.uni_trier.wi2.ProcakeExtensionLoggingUtils.METHOD_CALL;

public abstract class JSONtoFunctionConverter {

    /**
     * <p>returns the Java Object of which the given Map is the JSON-representation of
     *
     * <p>This function is the heartpiece of the JSONtoFunctionConverter.
     * After a JSON-representation of a functional Interface (MethodInvokersFunc, SimilarityMeasureFunc or WeightFunc)
     * has been converted in to a LinkedHashMap by the xml parser, the respective nodes have to be evaluated
     * using this function.
     *
     * <p>In order to evaluate the nodes \<q\\\> or \<c\\\> (see JSON schema), DataObjects q and c
     * have to be passed to the function, as well.
     *
     * <p>In case a functional Interface requires only one argument, q, c can be set so null.
     *
     * @param node the DOM node generated by the xml parser
     * @param q    the query object passed to the functional interface
     * @param c    the case object passed to the functional interface (if required, else null)
     * @return the Java Object of which the DOM node is the XML-representation
     * @throws ClassNotFoundException
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    protected static Object evaluate(Map node, DataObject q, DataObject c) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {

        switch ((String) node.get("element-type")) {

            // The "and" node represents the logical conjunction of the nodes in the list under "content"
            case "and":
                List conditions = (List) node.get("content");
                boolean value = true;
                for (int i = 0; i < conditions.size(); i++) {
                    if (!(boolean) evaluate((Map) conditions.get(i), q, c)) {
                        value = false;
                        break;
                    }
                }
                return value;

            // The "and" node represents the logical conjunction of the nodes in the list under "content"
            case "or":
                conditions = (List) node.get("content");
                value = false;
                for (int i = 0; i < conditions.size(); i++) {
                    if ((boolean) evaluate((Map) conditions.get(i), q, c)) {
                        value = true;
                        break;
                    }
                }
                return value;

            // The "not" node represents the logical negation the node under "content"
            case "not":
                value = !(boolean) evaluate((Map) node.get("content"), q, c);
                return value;

            // The "equals" node represents Java's "Object.equals" method
            case "equals":
                Object a = evaluate((Map) node.get("a"), q, c);
                Object b = evaluate((Map) node.get("b"), q, c);
                return a.equals(b);

            // The "equals" node represents Java's "==" equality
            case "same-object-as":
                a = evaluate((Map) node.get("a"), q, c);
                b = evaluate((Map) node.get("b"), q, c);
                return a == b;

            // The "instance-of" node represents Java's "instanceof" operator
            case "instance-of":
                a = evaluate((Map) node.get("a"), q, c);
                Class clazz = Class.forName((String) evaluate((Map) node.get("b"), q, c));
                return clazz.isInstance(a);

            // The "regex" node represents a regular expression test
            // It returns true if the string value under "b" matches the string value under "a"
            case "regex":
                Pattern pattern = Pattern.compile((String) evaluate((Map) node.get("pattern"), q, c));
                Matcher matcher = pattern.matcher((String) evaluate((Map) node.get("matcher"), q, c));
                value = matcher.matches();
                return value;

            // The "q" node represents the first argument passed to the functional interface which is generated by the
            //  respective converter
            case "q":
                return q;

            // The "c" node represents the second argument passed to the functional interface which is generated by the
            //  respective converter (if the functional interface requires one)
            case "c":
                return c;

            // The "string" node represents a String object
            case "string":
                String str = (String) node.get("value");
                return str;

            // The "double" node represents a Double object
            case "double":
                double dbl;
                Object val = node.get("value");
                if (val instanceof Double) {
                    dbl = (double) val;
                } else if (val instanceof Integer) {
                    dbl = (int) val;
                } else {
                    dbl = Double.parseDouble((String) node.get("value"));
                }
                return dbl;

            // The "boolean" node represents a Boolean object
            case "boolean":
                boolean bool;
                val = node.get("value");
                if (val instanceof Double) {
                    bool = ((double) val) > 0;
                } else if (val instanceof Integer) {
                    bool = ((int) val) > 0;
                } else {
                    bool = Boolean.parseBoolean((String) node.get("value"));
                }
                return bool;

            // The "character" node represents a Character object
            case "character":
                char chr = ((String) node.get("value")).charAt(0);
                return chr;

            // The "integer" node represents a Integer object
            case "integer":
                Integer itg = Integer.parseInt((String) node.get("value"));
                METHOD_CALL.trace("procake-extension.parsing.XMLtoFunctionConverter.evaluate" +
                        "(Node, DataObject, DataObject): return {}", itg);
                return itg;

            // The "byte" node represents a Byte object
            case "Byte":
                Byte bte = Byte.parseByte((String) node.get("value"));
                return bte;

            // The "method" node represents a method in Java.
            // A "method" node has an attribute "name" (=name of method) and arbitrarily many
            //  child nodes of node string, double or boolean.
            case "method":
                String name = (String) node.get("name");
                List<Map> arguments = (List<Map>) node.get("arguments");

                int numParams = 0;
                if (arguments != null) numParams = arguments.size();

                Class[] classes = new Class[numParams];
                Object[] objects = new Object[numParams];

                clazz = null;

                for (int i = 0; i < numParams; i++) {
                    Map argument = arguments.get(i);
                    if (argument.get("element-type").equals("string")) clazz = String.class;
                    if (argument.get("element-type").equals("double")) clazz = double.class;
                    if (argument.get("element-type").equals("boolean")) clazz = boolean.class;
                    if (argument.get("element-type").equals("character")) clazz = Character.class;
                    if (argument.get("element-type").equals("integer")) clazz = int.class;
                    if (argument.get("element-type").equals("byte")) clazz = byte.class;
                    classes[i] = clazz;
                    objects[i] = evaluate(argument, q, c);
                }
                MethodInvoker methodInvoker_ = new MethodInvoker(name, classes, objects);
                return methodInvoker_;

            // The "method-return-value" node represents the return value of a method (see above)
            case "method-return-value":
                MethodInvoker methodInvoker = (MethodInvoker) evaluate((Map) node.get("method"), q, c);
                Object methodReturnValue = methodInvoker.invoke(evaluate((Map) node.get("object"), q, c));
                return methodReturnValue;

            // The "method-list" node represents a list of methods
            case "method-list":
                ArrayList<MethodInvoker> methodInvokers = new ArrayList<>();
                List methods = (List) node.get("content");
                for (int i = 0; i < methods.size(); i++) {
                    methodInvokers.add((MethodInvoker) evaluate((Map) methods.get(i), q, c));
                }
                return methodInvokers;
            default:
                break;


        }
        return null;
    }

    /**
     * <p>Validates a JSON file (.json) gainst a JSON schema (.jschema) and returns the {@link ValidationMessage}s.</p>
     *
     * @param schema the JSON schema to be validated against
     * @param json  the JSON file to be validated
     * @return  set of ValidationMessages
     * @throws JsonProcessingException if the String json does not contain a well-formed JSON document
     */
    protected static Set<ValidationMessage> validate(String schema, String json) throws JsonProcessingException {
        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V4);
        JsonSchema jsonSchema = factory.getSchema(schema);
        JsonNode jsonNode = new ObjectMapper().readTree(json);
        Set<ValidationMessage> errors = jsonSchema.validate(jsonNode);

        return errors;
    }
}
