package de.uni_trier.wi2.parsing;

import de.uni_trier.wi2.procake.data.object.DataObject;
import de.uni_trier.wi2.utils.MethodInvoker;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXParseException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * <p>This abstract class delivers functionality for:
 * <ol>
 *     <li>initializing an inhibiting XMLtoFunctionConverter and</li>
 *     <li>evaluating the nodes generated by the DOM parser</li>
 * </ol>
 * <p>The three inhibiting classes
 * <ul>
 *     <li>XMLtoMethodInvokersFuncConverter,</li>
 *     <li>XMLtoSimilarityMeasureFuncConverter and</li>
 *     <li>XMLtoWeightFuncConverter</li>
 * </ul>
 * respectively provide a method ("getXYZFunc(File file)") for parsing and converting an XML file in to
 * the respective functional interface.
 *
 * <p>The actual conversion of the DOM provided by the xml parser however happens everytime the functional
 * interface is called, not in advance!
 */
public abstract class XMLtoFunctionConverter {

    /**
     * flag that shows if a function converter has been initialized yet
     */
    protected static boolean initialized = false;
    /**
     * the DocumentBuilder used for parsing the XML file
     */
    protected static DocumentBuilder dBuilder;

    /**
     * initializes the DocumentBuilder required for parsing the XML file
     *
     * @throws ParserConfigurationException
     */
    protected static void initialize() throws ParserConfigurationException {
        

        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        dbFactory.setValidating(true);
        dbFactory.setIgnoringElementContentWhitespace(true);
        dBuilder = dbFactory.newDocumentBuilder();

        dBuilder.setErrorHandler(new ErrorHandler() {
            @Override
            public void warning(SAXParseException exception) {
                exception.printStackTrace();
            }

            @Override
            public void error(SAXParseException exception) {
                exception.printStackTrace();
            }

            @Override
            public void fatalError(SAXParseException exception) {
                exception.printStackTrace();
            }
        });

    }

    /**
     * <p>returns the Java Object of which the given DOM-Node is the XML-representation
     *
     * <p>This function is the heartpiece of the XMLtoFunctionConverter.
     * After an XML-representation of a functional Interface (MethodInvokersFunc, SimilarityMeasureFunc or WeightFunc)
     * has been converted in to a document object model by the xml parser, the respective nodes have to be evaluated
     * using this function.
     *
     * <p>In order to evaluate the nodes \<q\\\> or \<c\\\> (see xml document type definitions), DataObjects q and c
     * have to be passed to the function, as well.
     *
     * <p>In case a functional Interface requires only one argument, q, c can be set so null.
     *
     * @param node the DOM node generated by the xml parser
     * @param q    the query object passed to the functional interface
     * @param c    the case object passed to the functional interface (if required, else null)
     * @return the Java Object of which the DOM node is the XML-representation
     * @throws ClassNotFoundException
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    protected static Object evaluate(Node node, DataObject q, DataObject c) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {


        switch (node.getNodeName()) {

            // The "and" node represents the logical conjunction of its child nodes
            case "and":
                NodeList conditions = node.getChildNodes();
                boolean value = true;
                for (int i = 0; i < conditions.getLength(); i++) {
                    if (!(boolean) evaluate(conditions.item(i), q, c)) {
                        value = false;
                        break;
                    }
                }

                return value;

            // The "or" node represents the logical disjunction of its child nodes
            case "or":
                conditions = node.getChildNodes();
                value = false;
                for (int i = 0; i < conditions.getLength(); i++) {
                    if ((boolean) evaluate(conditions.item(i), q, c)) {
                        value = true;
                        break;
                    }
                }

                return value;

            // The "not" node represents the logical negation of its child node
            case "not":
                value = !(boolean) evaluate(node.getFirstChild(), q, c);
                
                return value;

            // The "equals" node represents Java's "Object.equals" method
            case "equals":
                Object a = evaluate(node.getChildNodes().item(0), q, c);
                Object b = evaluate(node.getChildNodes().item(1), q, c);
                
                return a.equals(b);

            // The "equals" node represents Java's "==" equality
            case "same-object-as":
                a = evaluate(node.getChildNodes().item(0), q, c);
                b = evaluate(node.getChildNodes().item(1), q, c);
                
                return a == b;

            // The "instance-of" node represents Java's "instanceof" operator
            case "instance-of":
                a = evaluate(node.getChildNodes().item(0), q, c);
                Class clazz = Class.forName((String) evaluate(node.getChildNodes().item(1), q, c));
                
                return clazz.isInstance(a);

            // The "regex" node represents a regular expression test
            // It returns true if the nodes second child node matches the nodes first child node
            case "regex":
                Pattern pattern = Pattern.compile((String) evaluate(node.getChildNodes().item(0), q, c));
                Matcher matcher = pattern.matcher((String) evaluate(node.getChildNodes().item(1), q, c));
                value = matcher.matches();

                return value;

            // The "q" node represents the first argument passed to the functional interface which is generated by the
            //  respective converter
            case "q":
                return q;

            // The "c" node represents the second argument passed to the functional interface which is generated by the
            //  respective converter (if the functional interface requires one)
            case "c":
                return c;

            // The "string" node represents a String object
            case "string":
                String str = node.getAttributes().item(0).getNodeValue();
                
                return str;

            // The "double" node represents a Double object
            case "double":
                Double dbl = Double.parseDouble(node.getAttributes().item(0).getNodeValue());
                
                return dbl;

            // The "boolean" node represents a Boolean object
            case "boolean":
                boolean bool = Boolean.parseBoolean(node.getAttributes().item(0).getNodeValue());
                
                return bool;

            // The "character" node represents a Character object
            case "character":
                char chr = node.getAttributes().item(0).getNodeValue().charAt(0);
                
                return chr;

            // The "integer" node represents a Integer object
            case "integer":
                Integer itg = Integer.parseInt(node.getAttributes().item(0).getNodeValue());
                
                return itg;

            // The "method" node represents a method in Java.
            // A "method" node has an attribute "name" (=name of method) and arbitrarily many
            //  child nodes of node string, double or boolean.
            case "method":
                String methodName = node.getAttributes().item(0).getNodeValue();
                NodeList children = node.getChildNodes();
                int numParams = children.getLength();

                Class[] classes = new Class[numParams];
                Object[] objects = new Object[numParams];

                clazz = null;

                for (int i = 0; i < numParams; i++) {
                    Node child = children.item(i);
                    if (child.getNodeName().equals("string")) clazz = String.class;
                    if (child.getNodeName().equals("double")) clazz = double.class;
                    if (child.getNodeName().equals("boolean")) clazz = boolean.class;
                    if (child.getNodeName().equals("character")) clazz = Character.class;
                    if (child.getNodeName().equals("integer")) clazz = int.class;
                    if (child.getNodeName().equals("byte")) clazz = byte.class;
                    classes[i] = clazz;
                    objects[i] = evaluate(child, q, c);
                }
                MethodInvoker methodInvoker_ = new MethodInvoker(methodName, classes, objects);

                return methodInvoker_;

            // The "method-return-value" node represents the return value of a method (see above)
            case "method-return-value":
                MethodInvoker methodInvoker = (MethodInvoker) evaluate(node.getChildNodes().item(1), q, c);
                Object methodReturnValue = methodInvoker.invoke(evaluate(node.getChildNodes().item(0), q, c));
                
                return methodReturnValue;

            // The "method-list" node represents a list of methods
            case "method-list":
                ArrayList<MethodInvoker> methodInvokers = new ArrayList<>();
                children = node.getChildNodes();
                for (int i = 0; i < children.getLength(); i++) {
                    methodInvokers.add((MethodInvoker) evaluate(children.item(i), q, c));
                }

                return methodInvokers;
            default:
                break;
        }
        return null;
    }
}