package de.uni_trier.wi2.parsing;

import de.uni_trier.wi2.parsing.model.*;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXParseException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.lang.reflect.InvocationTargetException;


/**
 * <p>This abstract class delivers functionality for:
 * <ol>
 *     <li>initializing an inhibiting XMLtoFunctionConverter and</li>
 *     <li>evaluating the nodes generated by the DOM parser</li>
 * </ol>
 * <p>The three inhibiting classes
 * <ul>
 *     <li>XMLtoMethodInvokersFuncConverter,</li>
 *     <li>XMLtoSimilarityMeasureFuncConverter and</li>
 *     <li>XMLtoWeightFuncConverter</li>
 * </ul>
 * respectively provide a method ("getXYZFunc(File file)") for parsing and converting an XML file in to
 * the respective functional interface.
 *
 * <p>The actual conversion of the DOM provided by the xml parser however happens everytime the functional
 * interface is called, not in advance!
 */
public abstract class XMLtoFunctionConverter {

    /**
     * flag that shows if a function converter has been initialized yet
     */
    protected static boolean initialized = false;
    /**
     * the DocumentBuilder used for parsing the XML file
     */
    protected static DocumentBuilder dBuilder;

    /**
     * initializes the DocumentBuilder required for parsing the XML file
     *
     * @throws ParserConfigurationException
     */
    protected static void initialize() throws ParserConfigurationException {


        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        dbFactory.setValidating(true);
        dbFactory.setIgnoringElementContentWhitespace(true);
        dBuilder = dbFactory.newDocumentBuilder();

        dBuilder.setErrorHandler(new ErrorHandler() {
            @Override
            public void warning(SAXParseException exception) {
                exception.printStackTrace();
            }

            @Override
            public void error(SAXParseException exception) {
                exception.printStackTrace();
            }

            @Override
            public void fatalError(SAXParseException exception) {
                exception.printStackTrace();
            }
        });

    }

    /**
     * <p>returns the Java Object of which the given DOM-Node is the XML-representation
     *
     * <p>This function is the heartpiece of the XMLtoFunctionConverter.
     * After an XML-representation of a functional Interface (MethodInvokersFunc, SimilarityMeasureFunc or WeightFunc)
     * has been converted in to a document object model by the xml parser, the respective nodes have to be evaluated
     * using this function.
     *
     * <p>In order to evaluate the nodes \<q\\\> or \<c\\\> (see xml document type definitions), DataObjects q and c
     * have to be passed to the function, as well.
     *
     * <p>In case a functional Interface requires only one argument, q, c can be set so null.
     *
     * @param node the DOM node generated by the xml parser
     * @param q    the query object passed to the functional interface
     * @param c    the case object passed to the functional interface (if required, else null)
     * @return the Java Object of which the DOM node is the XML-representation
     * @throws ClassNotFoundException
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    protected static Component evaluate(Node node) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {


        final String nodeName = node.getNodeName();
        switch (nodeName) {

            // The "and" node represents the logical conjunction of its child nodes
            case "and":
                NodeList conditions = node.getChildNodes();
                int amountOfConditions = conditions.getLength();
                LogicalOrConditionComponent[] logicalOrConditionComponents = new LogicalOrConditionComponent[amountOfConditions];
                for (int i = 0; i < amountOfConditions; i++) {
                    logicalOrConditionComponents[i] = (LogicalOrConditionComponent) evaluate(conditions.item(i));
                }
                return new AndComponent(logicalOrConditionComponents);

            // The "or" node represents the logical disjunction of its child nodes
            case "or":
                conditions = node.getChildNodes();
                amountOfConditions = conditions.getLength();
                logicalOrConditionComponents = new LogicalOrConditionComponent[amountOfConditions];
                for (int i = 0; i < amountOfConditions; i++) {
                    logicalOrConditionComponents[i] = (LogicalOrConditionComponent) evaluate(conditions.item(i));
                }
                return new OrComponent(logicalOrConditionComponents);

            // The "not" node represents the logical negation of its child node
            case "not":
                Node firstChild = node.getFirstChild();
                return new NotComponent((LogicalOrConditionComponent) evaluate(firstChild));

            // The "equals" node represents Java's "Object.equals" method
            case "equals":
                ObjectOrValueComponent object1 = (ObjectOrValueComponent) evaluate(node.getChildNodes().item(0));
                ObjectOrValueComponent object2 = (ObjectOrValueComponent) evaluate(node.getChildNodes().item(1));

                return new EqualsComponent(object1, object2);

            // The "equals" node represents Java's "==" equality
            case "same-object-as":
                object1 = (ObjectOrValueComponent) evaluate(node.getChildNodes().item(0));
                object2 = (ObjectOrValueComponent) evaluate(node.getChildNodes().item(1));

                return new SameObjectAsComponent(object1, object2);

            // The "instance-of" node represents Java's "instanceof" operator
            case "instance-of":
                ObjectComponent objectComponent = (ObjectComponent) evaluate(node.getChildNodes().item(0));
                StringComponent stringComponent = (StringComponent) evaluate(node.getChildNodes().item(1));

                return new InstanceOfComponent(objectComponent, stringComponent);

            // The "regex" node represents a regular expression test
            // It returns true if the nodes second child node matches the nodes first child node
            case "regex":
                StringOrMethodReturnValueComponent pattern = (StringOrMethodReturnValueComponent) evaluate(node.getChildNodes().item(0));
                StringOrMethodReturnValueComponent string = (StringOrMethodReturnValueComponent) evaluate(node.getChildNodes().item(1));

                return new RegexComponent(pattern, string);

            // The "q" node represents the first argument passed to the functional interface which is generated by the
            //  respective converter
            case "q":
                return new QComponent();

            // The "c" node represents the second argument passed to the functional interface which is generated by the
            //  respective converter (if the functional interface requires one)
            case "c":
                return new CComponent();

            // The "string" node represents a String object
            case "string":
                String str = node.getAttributes().item(0).getNodeValue();

                return new StringComponent(str);

            // The "double" node represents a Double object
            case "double":
                Double dbl = Double.parseDouble(node.getAttributes().item(0).getNodeValue());

                return new DoubleComponent(dbl);

            // The "boolean" node represents a Boolean object
            case "boolean":
                boolean bool = Boolean.parseBoolean(node.getAttributes().item(0).getNodeValue());

                return new BooleanComponent(bool);

            // The "character" node represents a Character object
            case "character":
                char chr = node.getAttributes().item(0).getNodeValue().charAt(0);

                return new CharacterComponent(chr);

            // The "integer" node represents a Integer object
            case "integer":
                Integer itg = Integer.parseInt(node.getAttributes().item(0).getNodeValue());

                return new IntegerComponent(itg);

            // The "method" node represents a method in Java.
            // A "method" node has an attribute "name" (=name of method) and arbitrarily many
            //  child nodes of node string, double or boolean.
            case "method":
                String methodName = node.getAttributes().item(0).getNodeValue();
                NodeList children = node.getChildNodes();
                int numParams = children.getLength();
                ValueComponent[] valueComponents = new ValueComponent[numParams];

                for (int i = 0; i < numParams; i++) {
                    Node child = children.item(i);
                    valueComponents[i] = (ValueComponent) evaluate(child);
                }
                return new MethodComponent(methodName, valueComponents);

            // The "method-return-value" node represents the return value of a method (see above)
            case "method-return-value":
                MethodComponent methodComponent = (MethodComponent) evaluate(node.getChildNodes().item(1));
                objectComponent = (ObjectComponent) evaluate(node.getChildNodes().item(0));

                return new MethodReturnValueComponent(objectComponent, methodComponent);

            // The "method-list" node represents a list of methods
            case "method-list":
                children = node.getChildNodes();
                int amountOfChildren = children.getLength();
                MethodComponent[] methods = new MethodComponent[amountOfChildren];
                for (int i = 0; i < amountOfChildren; i++) {
                    methods[i] = (MethodComponent) evaluate(children.item(i));
                }

                return new MethodListComponent(methods);
            case "function":
                NamedNodeMap attributes = node.getAttributes();
                String functionName = attributes.getNamedItem("name").getNodeValue();
                Node arg1 = attributes.getNamedItem("arg1");
                Node arg2 = attributes.getNamedItem("arg2");
                Node arg3 = attributes.getNamedItem("arg3");
                return new FunctionComponent(functionName, arg1 == null ? null : arg1.getNodeValue(), arg2 == null ? null : arg2.getNodeValue(), arg3 == null ? null : arg3.getNodeValue());
            default:
                System.out.println("WARNING: Unknown element \"" + nodeName + "\"");
                return null;
        }
    }


}